Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

Example 1:
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.

Example 2:
Input: height = [4,2,0,3,2,5]
Output: 9

Constraints:
n == height.length
1 <= n <= 2 * 104
0 <= height[i] <= 105


Intuition / Approach: 
    To determine the amount of trapped water, we need the max walls on either side.
    And the decider height would be minimum of both the walls.
    Things is what we need is not the exact values of the heights on either side, but the minimum of max of either side. Because that's the decider due to bigger wall is a protector one.
    How high is the bigger wall, it doesn't matter but what's the height of the smaller one is the key.
    Hence if we start from either extrem ends 0 and n-1, and maintain the max heights from left and right. Then minimum of these 2 would be the decider of the amount of trapped water.
    So following the 2 pointer mechanism, we now have to decide how to move ahead or move both pointers ? 
    We move forward the in the original direction that pointer which's height is lower. 
    This can be hard to digest at first, but just look at cases which we have to focus:
        1. what will be the level of water , will be decided by the extreme ends in the windows we are in.
        2. but as we move a smaller window can be reversed in the form-factor or the decider wall. Because if in the start the left one is the smaller that becomes the decide, hence we move the left one.
           But when we move ahead and at arbitrary point i, it is possible that h[left] (left = i) is bigger than the h[right]. hence new window/bucket formed would be having different level of water.
           Hence in that case right pointer needs to move (means --right). Becuase that now becomes the decider for the amount of water trapped.

    int trap(vector<int>& height) {
        int leftMax = 0, rightMax = 0;
        int l = 0, r = height.size()-1;
        int ans = 0;
        while(l < r) {
            if(height[l] < height[r]) {
                leftMax = max(leftMax, height[l]);
                ans += leftMax - height[l];
                ++l;
            }
            else {
                rightMax = max(rightMax, height[r]);
                ans += rightMax - height[r];
                --r;
            }
        }
        return ans;
    }

// T.C. : O(N)
// S.C. : O(1)
